% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/unify_catboost.R
\name{catboost.unify}
\alias{catboost.unify}
\title{Unify Catboost model}
\usage{
catboost.unify(catboost_model, pool, data, recalculate = FALSE)
}
\arguments{
\item{catboost_model}{An object of \code{catboost.Model} class. At the moment, models built on data with categorical features
are not supported - please encode them before training.}

\item{pool}{An object of \code{catboost.Pool} class used for training the model}

\item{data}{data.frame for which calculations should be performed.}

\item{recalculate}{logical indicating if covers should be recalculated according to the dataset given in data. Keep it FALSE if training data are used.}
}
\value{
Each row of a returned data frame indicates a specific node. The object has a defined structure:
\describe{
\item{Tree}{0-indexed ID of a tree}
\item{Node}{0-indexed ID of a node in a tree}
\item{Feature}{In case of an internal node - name of a feature to split on. Otherwise - NA}
\item{Decision.type}{A factor with two levels: "<" and "<=". In case of an internal node - predicate used for splitting observations. Otherwise - NA}
\item{Split}{For internal nodes threshold used for splitting observations. All observations that satisfy the predicate Decision.type(Split) ('< Split' / '<= Split') are proceeded to the node marked as 'Yes'. Otherwise to the 'No' node. For leaves - NA}
\item{Yes}{Index of a row containing a child Node. Thanks to explicit indicating the row it is much faster to move between nodes}
\item{No}{Index of a row containing a child Node}
\item{Missing}{Index of a row containing a child Node where are proceeded all observations with no value of the dividing feature. When the model did not meet any missing value in the feature, it is not specified (marked as NA)}
\item{Prediction}{For leaves: Value of prediction in the leaf. For internal nodes: NA}
\item{Cover}{Number of observations collected by the leaf or seen by the internal node}
}
}
\description{
Convert your GBM model into a standarised data frame.
The returned data frame is easy to be interpreted by user and ready to be used as an argument in \code{treeshap()} function
}
\examples{
# library(catboost)
# data <- fifa20$data[colnames(fifa20$data) != 'work_rate']
# label <- fifa20$target
# dt.pool <- catboost::catboost.load_pool(data = as.data.frame(lapply(data, as.numeric)),
#                                        label = label)
# cat_model <- catboost::catboost.train(
#             dt.pool,
#             params = list(loss_function = 'RMSE',
#                           iterations = 100,
#                           metric_period = 10,
#                           logging_level = 'Silent'))
# catboost.unify(cat_model, dt.pool)
}
\seealso{
\code{\link{xgboost.unify}} for \code{XGBoost models}

\code{\link{lightgbm.unify}} for \code{LightGBM models}

\code{\link{gbm.unify}} for \code{GBM models}
}
